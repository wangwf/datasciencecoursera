PA2 - explore the NOAA Storm Database and identify harmful events to popolation health and economic.
=========================================


Title: Your document should have a title that briefly summarizes your data analysis

Synopis
---------------------------------
Synopsis: Immediately after the title, there should be a synopsis which describes and summarizes your analysis in at most 10 complete sentences.

Storms and other severe weather events can cause both public health and economic problems for communities and municipalities. Many severe events can result in fatalities, injuries, and property damage, and preventing such outcomes to the extent possible is a key concern.

This project  explores the U.S. National Oceanic and Atmospheric Administration's (NOAA) storm database. This database tracks characteristics of major storms and weather events in the United States, including when and where they occur, as well as estimates of any fatalities, injuries, and property damage.



Two the following questions:
* Across the United States, which types of events (as indicated in the EVTYPE variable) are most harmful with respect to population health?

* Across the United States, which types of events have the greatest economic consequences?

Data Processing
--------------------------------------
There should be a section titled Data Processing which describes (in words and code) how the data were loaded into R and processed for analysis. In particular, your analysis must start from the raw CSV file containing the data. You cannot do any preprocessing outside the document. If preprocessing is time-consuming you may consider using the cache = TRUE option for certain code chunks.



## Read data file 
```{r readDatafile,echo=TRUE}

fname="StormData.csv"
if(!file.exists(fname)){
    dataURL="https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"
    temp <-"StormData.csv.bz2"
    download.file(dataURL, temp, method="curl")
    library(R.utils)
    bunzip2(temp,"StormData.csv",remove=FALSE)
    unlink(temp)
}else{
    message("data already downloaded.")
}

#data <- read.table(fname, header=TRUE, nrow=100, sep=",")
#classes <- sapply(data, class)
#data<- read.table(fname, header=TRUE, sep=",", col.names=classes)
data <- read.csv(fname)

```


Summary of data
```{r data_summary, echo=TRUE}
dim(data)
#summary(data)
head(data)
str(data)
```

Here we are only interesting data on US, so using R's built-in `state.abb` dataset to restrict the records of US states.
```{r }
data <- data[data$STATE %in% state.abb,]
```

Covert BGN_DATE field into a date class.
```{r convertdates, cache=TRUE}
data$BGN_DATE <- as.Date(as.POSIXlt(data$BGN_DATE,format="%m/%d/%Y %H:%M:%S"))
data$beginDate <- as.Date(as.POSIXct(data$BGN_DATE,format="%m/%d/%Y %H:%M:%S"))
```

```{r }
# library(data.table)
# D <- data.table(data)
# #data$date <- as.Date(data$date, format="%Y-%m-%d")
# colnames(data)[grepl("DMGEXP",colnames(data))]
# data$propdmgcost <- data$propdmg * data$propdmgexp
```


Look the EVTYPE variable and find what kind of event recorded.
```{r}
levels(data$EVTYPE)
nEVTYPE <- length(levels(data$EVTYPE))
message(sprintf("Number of unique values of evtype: %.0d", length(unique(data$EVTYPE))))
```
There are `r nEVTYPE` types of events recorded in this database, listed as above. The unique number is too large to manage without grouping. Here we refer the group categories found in the [2009 Annual Summaries](http://www.ncdc.noaa.gov/oa/climate/sd/annsum2009.pdf) on page 3. There are 7 categories: Convection, Extreme Temperature, Flood, Marine, Tropical Cyclones, Winter and Other. In each category has many even types.

```{r}
Lightning    <- "\\bL\\S+?G\\b"
Tornado      <- "(NADO)|(\\bTOR\\S+?O\\b|(\\bFUN))"
Thunderstorm <- "THUNDERSTORM|TSTM"
Wind         <- "(WIND)|(WND)"
Hail         <- "HAIL"
regex <- paste(lightning, Tornado, Thunderstorm, Wind, Hail, sep="|")

data$eventConvection <- grepl(regex, data$EVTYPE, ignore.case = TRUE)

#D <- D[, eventConvection := indicator(regex)]
```


For variations of **Cold** and **Heat**, list the event types that fall into the category of **Extreme Temperatures**.
```{r}
regex <- "COLD|HEAT"
data$eventExtremeTemp <- grepl(regex, data$EVTYPE, ignore.case = TRUE)
```

For variations of **Flood** and **Rain**,list the event types that fall into the category of **Flood**.
```{r}
Flood <- "(\\bFL\\S+?D)"
Rain  <- "RAIN|PRECIP|SHOWER"
regex <- paste(Flood, Rain, sep="|")

data$eventFlood <- grepl(regex, data$EVTYPE, ignore.case = TRUE)
```

For variations of **Snow**, **Ice**, **Freeze**, or **Winter Weather**,
list the event types that fall into the category of **Winter**.
```{r}
regex <- "(SNOW)|(ICE)|(ICY)|(FREEZ)|(WINT)"
data$eventWinter <- grepl(regex, data$EVTYPE, ignore.case = TRUE)
```



Next, scale the property damage variable into a new variable, `propertyDamage`.

* If `propdmgexp` = `B`, then multiply `propdmg` by 1,000,000,000
* Else if `propdmgexp` = `M`, then multiply `propdmg` by 1,000,000
* Else if `propdmgexp` = `K`, then multiply `propdmg` by 1,000
* Else if `propdmgexp` = `H`, then multiply `propdmg` by 100
* Else leave `propdmg` as-is

```{r propertyDamage}
data$PROPDMGEXP <- toupper(data$PROPDMGEXP)
data$propertyDamage <- ifelse(data$PROPDMGEXP == "B", data$PROPDMG*1E9,
                              ifelse(data$PROPDMGEXP == "M", data$PROPDMG*1E6,
                                     ifelse(data$PROPDMGEXP == "K", data$PROPDMG*1E3,
                                         ifelse(data$PROPDMGEXP == "H", data$PROPDMG*1E2,
                                                data$PROPDMG
                                             ))))

#D <- D[, propdmgexp := toupper(propdmgexp)]
#D[, .N, propdmgexp]
#D <- D[, propertyDamage := ifelse(propdmgexp == "B", propdmg * 1E9, ifelse(propdmgexp == "M", propdmg * 1E6, ifelse(propdmgexp == "K", propdmg * 1E3, ifelse(propdmgexp == "H", propdmg * 1E2, propdmg))))]
summary(data$propertyDamage)
```

Scale the crop damage variable into a new variable, `cropDamage`.

* If `cropdmgexp` = `B`, then multiply `cropdmg` by 1,000,000,000
* Else if `cropdmgexp` = `M`, then multiply `cropdmg` by 1,000,000
* Else if `cropdmgexp` = `K`, then multiply `cropdmg` by 1,000
* Else leave `cropdmg` as-is

```{r}
data$CROPDMGEXP <- toupper(data$CROPDMGEXP)
data$cropDamage <- ifelse(data$CROPDMGEXP == "B", data$CROPDMG*1E9,
                              ifelse(data$CROPDMGEXP == "M", data$CROPDMG*1E6,
                                     ifelse(data$CROPDMGEXP == "K", data$CROPDMG*1E3,
                                         ifelse(data$CROPDMGEXP == "H", data$CROPDMG*1E2,
                                                data$CROPDMG
                                                ))))
                                                
#D <- D[, cropdmgexp := toupper(cropdmgexp)]
#D[, .N, cropdmgexp]
#D <- D[, cropDamage := ifelse(cropdmgexp == "B", cropdmg * 1E9, ifelse(cropdmgexp == "M", cropdmg * 1E6, ifelse(cropdmgexp == "K", cropdmg * 1E3, cropdmg)))]
summary(data$cropDamage)
```


#### Group event types



Calculate the proportion of records that don't satisfy any one of the defined indicators.
Calculate the number of unique event types among these records.
List the ungrouped unique event types.
Create an **Other** indicator for ungrouped event types.


```{r}
where <- expression(data$eventConvection == FALSE & data$eventExtremeTemp == FALSE & data$eventFlood == FALSE & data$eventWinter == FALSE)
message(sprintf("Number (%%) of records that don't satisfy any one of the defined indicators: %.0d (%.2f%%)", mean(eval(where))*100 ))

#where <- expression(eventConvection == FALSE & eventExtremeTemp == FALSE & eventFlood == FALSE & eventWinter == FALSE)
#ungrouped <- D[eval(where), list(n = .N, prop = .N / nrow(D))]
#prop <- D[eval(where), .N / nrow(D)]
#message(sprintf("Number (%%) of records that don't satisfy any one of the defined indicators: %.0d (%.2f%%)", ungrouped$n, ungrouped$prop * 100))
#uniqueEvtype <- unique(D[eval(where), evtype])
#message(sprintf("Number of unique event types that don't satisfy any one of the defined indicators: %.0d", length(uniqueEvtype)))
#uniqueEvtype[order(uniqueEvtype)]
data$eventOther <- eval(where)
```


A crosstabulation for the event type categories is below.

```{r}
groupby<- expression(list(data$eventConvection, data$eventExtremeTemp, data$eventFlood,data$eventWinter, data$eventOther))

library(data.table)
D <- data.table(data)
groupby <- expression(list(eventConvection, eventExtremeTemp, eventFlood, eventWinter, eventOther))
D[, .N, eval(groupby)][order(eventConvection, eventExtremeTemp, eventFlood, eventWinter, eventOther, decreasing=TRUE)]
```

#### Categorize event types

Now that event types are grouped, set up a categorization hierarchy of event
types.
The hierarchy is needed because records can have multiple events listed in the
`evtype` variable.
E.g., *THUNDERSTORM WINDS/FLASH FLOOD*.

The hierarchy is as follows.

1. Convection (including lightning, tornado, thunderstorm, wind, and hail)
2. Extreme temperature (including hot and cold)
3. Flood (including flood, flash flood, rain)
4. Winter (including snow, ice, freeze, or winter weather)
5. Other

Under this categorization hierarchy, the example event type of *THUNDERSTORM
WINDS/FLASH FLOOD* would be assigned to the *Convection* category.
I.e., higher categories outrank lower categories.

```{r}
data$eventCategory <- ifelse(data$eventConvection, 1,
                             ifelse(data$eventExtremeTemp, 2,
                                    ifelse(data$eventFlood, 3,
                                           ifelse(data$eventWinter, 4,
                                                  ifelse(data$eventOther, 5,
                                                         NA
                                                         )))))
dt<- table(data$eventCategory)
dimnames(dt)[[1]] = c("Convection", "Extreme temperature", "Flood", "Winter", "Other")
barplot(dt)

#D <- D[, eventCategory := ifelse(eventConvection, 1, ifelse(eventExtremeTemp, 2, ifelse(eventFlood, 3, ifelse(eventWinter, 4, ifelse(eventOther, 5, NA)))))]
#labels <- c("Convection", "Extreme temperature", "Flood", "Winter", "Other")
#D <- D[, eventCategory := factor(eventCategory, labels=labels)]
#D[, .N, eventCategory]
```


### Restrict date range

The date ranges for each category are below.

```{r}
d1<- aggregate(beginDate~eventCategory, data, min)
d2<- aggregate(beginDate~eventCategory, data, max)

plot(data$propertyDamage,data$eventCategory)

select <- expression(list(numberEvents = .N, minDate = min(data$beginDate), maxDate = max(data$beginDate)))


select <- expression(list(numberEvents = .N, minDate = min(beginDate), maxDate = max(beginDate)))
groupby <- expression(list(eventCategory))
tabEventCategory <- D[, eval(select), eval(groupby)]
tabEventCategory <- tabEventCategory[order(eventCategory)]
message(sprintf("Convection events reach as far back as %.0d.", year(min(D$beginDate[D$eventCategory == "Convection"]))))
message(sprintf("However, the other categories only reach as far back as %.0d.", year(min(D$beginDate[D$eventCategory != "Convection"]))))
```

Filter the data to include records with dates between a range that includes all categories.

```{r}
minYear <- year(min(D$beginDate[D$eventCategory != "Convection"]))
maxYear <- year(max(D$beginDate))
D <- D[minYear <= year(beginDate) & year(beginDate) <= maxYear]
message(sprintf("For the purpose of this analysis, the date range will be limited to %.0d to %.0d.", minYear, maxYear))
```


### Reshape data

Reshape data table with essential variables for tabulation and plotting.

```{r}
labels <- c("Convection", "Extreme temperature", "Flood", "Winter", "Other")
D2 <- rbind(D[, list(STATE, year = year(beginDate), eventCategory = factor(eventCategory, labels=labels), outcome = "Fatalities (thousands)", value = fatalities / 1E3)],
            D[, list(STATE, year = year(beginDate), eventCategory = factor(eventCategory, labels=labels), outcome = "Injuries (thousands)", value = injuries / 1E3)],
            D[, list(STATE, year = year(beginDate), eventCategory = factor(eventCategory, labels=labels), outcome = "Property damage ($, billions)", value = propertyDamage / 1E9)])
```

Tabulate by state and category, and by state.
For the state tabulation, rank each state according to outcome.

```{r}
tabulationStateCategory <- D2[, list(value = sum(value)), list(state, eventCategory, outcome)]
tabulationState <- D2[, list(value = sum(value)), list(state, outcome)]
tabulationState <- tabulationState[, rank := abs(rank(value, ties.method="random") - 51), list(outcome)]
```


## Results

Plot each outcome by state.
The color of each bar segment corresponds to event category.
The outcomes combine data from `r minYear` to `r maxYear`.

```{r smallmultiples, fig.width=15}
library(ggplot2)
ggplot(tabulationStateCategory, aes(x=state, y=value, fill=eventCategory)) +
  geom_bar(alpha=1/2, stat="identity") +
  scale_fill_brewer(name="Category", palette="Set1") +
  scale_x_discrete(name="") +
  scale_y_continuous(name="") +
  facet_wrap(~ outcome, scales="free", nrow=3, ncol=1) +
  theme(legend.position="bottom")
```

Tabulate the highest ranking state for each outcome.

**Fatalities**

```{r, results="asis"}
top <- tabulationState[grepl("Fatal", outcome) & rank <= 1, state]
where <- expression(state %in% top & grepl("Fatal", outcome))
select <- expression(list(state, value = format(value * 1E3, big.mark=","), eventCategory))
tabulation <- tabulationStateCategory[eval(where), eval(select)]
tabulation <- tabulation[order(value, decreasing=TRUE)]
library(xtable)
print(xtable(tabulation, digits=0), type="html", include.rownames=FALSE)
```

**Injuries**

```{r, results="asis"}
top <- tabulationState[grepl("Inj", outcome) & rank <= 1, state]
where <- expression(state %in% top & grepl("Inj", outcome))
select <- expression(list(state, value = format(value * 1E3, big.mark=","), eventCategory))
tabulation <- tabulationStateCategory[eval(where), eval(select)]
tabulation <- tabulation[order(value, decreasing=TRUE)]
print(xtable(tabulation, digits=0), type="html", include.rownames=FALSE)
```

**Property damage**

```{r, results="asis"}
top <- tabulationState[grepl("Prop", outcome) & rank <= 1, state]
where <- expression(state %in% top & grepl("Prop", outcome))
select <- expression(list(state, value = sprintf("$%s billion", format(round(value, digits=1), big.mark=",")), eventCategory))
tabulation <- tabulationStateCategory[eval(where), eval(select)]
tabulation <- tabulation[order(value, decreasing=TRUE)]
print(xtable(tabulation, digits=0), type="html", include.rownames=FALSE)
```

